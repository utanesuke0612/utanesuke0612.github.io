---
layout: post
title: Python入门-Liao-03-函数
date: 2017-09-09 22:47:59
categories: Python
tags: 廖雪峰教程 Python
---
* content
{:toc}

> [Python-Liao-XX...]系列,系列根据廖雪峰的python3初级教程学习整理。

# 1. 函数

Python内置了很多有用的函数，我们可以直接调用。示例代码:

```python
In [157]: abs(-20)
Out[157]: 20

In [158]: max(1,2,3,4,5,4,-9,000,999)
Out[158]: 999

In [160]: int("124")
Out[160]: 124

In [161]: str(1.23)
Out[161]: '1.23'

In [162]: bool(1)
Out[162]: True

In [163]: bool('')
Out[163]: False

In [166]: hex(15)
Out[166]: '0xf'

```

函数名其实就是指向一个函数对象的引用， 完全可以把函数名赋给一个 变量，相当于给这个函数起了一个“别名”：

```python
In [164]: mymax = max

In [165]: mymax(12,2,3,4)
Out[165]: 12
```


# 2. 定义函数

```python
def my_abs(x):
   if x >= 0:
      return x
   else:
      return -x
```
如果没有 return 语句， 函数执行完毕后也会返回结果， 只是结果为 None。
return None 可以简写为 return。

## 2.1 空函数 `pass`

```python
def nop():
  pass
```

上面定义了一个什么也不做的空函数，可以用来作为占位符，即函数还没有想好怎么写，可以先放一个pass，让程序先运行起来。
pass也可以单独放在语句中，如

```python
if age >= 18:
   pass
```

## 2.2 参数检查
调用函数的时候，如果参数个数不对，Python解释器会自动检查出来，但是类型不对，则无法检查，需要自己进行类型检查，如下：

```python
def myabs(x):
    if not isinstance(x,(int,float)):
        raise TypeError("type error")
    if x >= 0:
        return x
    else:
        return -x

a = myabs("ff")
print(a)

```
运行后触发异常处理。


## 2.3 返回多个值

```python
def returnTheName():
    return "lijun","wangling"

x,y = returnTheName()
print(x)
print("and")
print(y)

r = returnTheName()
print(r)
```

输出：

```python
lijun
and
wangling
('lijun', 'wangling')
```

- 返回多个值，其实只是一个假象，返回的实际上是个元组tuple。
- 但是，在语法上，返回一个 tuple 可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值。
所以，Python 的函数返回多值其实就是返回一个tuple，但写起来更方便。



# 3. 函数的参数

```python
def mypower(m,x):
    s = 1
    while x > 0:
        x = x - 1
        s = s*m
    return s

m = mypower(5,3)
print(m)
```

## 3.1 默认参数
- 默认参数，`def mypower(m,x=2):`,使用 `mypower(4)`形式调用的时候，默认使用x=2计算。
默认参数降低了函数调用的难度，而一旦需要更复杂的调用时， 又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只 需要定义一个。

-


递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可 以写成循环的方式，但循环的逻辑不如递归清晰。

```python
In [1]: f = abs

In [2]: f(-10)
Out[2]: 10

In [4]: def max(a,b,f):
   ...:     if f(a) > f(b):
   ...:         return f(a)
   ...:     else:
   ...:         return f(b)
   ...:

In [5]: max(-9,2,f)
Out[5]: 9

```


```python

In [6]: def fact(n):
   ...:     if n == 1:
   ...:         return 1
   ...:     return n * fact(n -1)
   ...:


In [8]: fact(5)
Out[8]: 120

```




```python
import time


def startTime():
    start = time.time()
    return start

def diffTime(start):
    elapsed_time = time.time() - start
    print ("elapsed_time:{0}".format(elapsed_time) + "[sec]")


def testTime():
    n = int(input("loop number:"))
    start = startTime()

    # test start
    for i in range(n):
        print(i)
    # test end

    diffTime(start)

testTime()


```



练习 汉诺塔的移动可以用递归函数非常简单地实现。
请编写 move(n, a, b, c)函数，它接收参数 n，表示 3 个柱子 A、B、C 中第 1 个柱子 A 的盘子数量，然后打印出把所有盘子从 A 借助 B 移动 到 C 的方法，
例如： def move(n, a, b, c):
---- pass ----
# 期待输出:
# A --> C
# A --> B
# C --> B
# A --> C
# B --> A
# B --> C
# A --> C


韩罗塔的递归方式
https://www.zhihu.com/question/24385418


作者：YIHE陳
链接：https://www.zhihu.com/question/24385418/answer/46241635
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

【图例】只有经历“移动最大盘子”这个步骤，余下的事情才有可能实现。
1. 而在此之前，我们所要做的事情，就是让“移动最大盘子”这个步骤得以实现。
2. 现在，游戏整个过程以“移动最大盘子”为中央，被分为了两部分。
3. 即（前）“将那坨N-1个盘子从A针移动到B针”，(中)“移动最大盘子”，(后)“将坨N-1个盘子从B针移动到C针”。
4. 这是我们意识到，（前）与（后）操作道理是相似的。不去管那个最大盘子，（前）是以C针为中转站，（后）是以A针为中转站。因此两者所需的移动次数应当是相等的。这意味着我们只要计算出其中一者的移动次数，然而乘以2，在加上“移动最大盘子”的那1次，就是这场游戏的总移动次数了。用数学语言表达，假设（前）“将N-1个盘子从A针移动到B针”所需次数为Hn-1，总移动次数为Hn，那么可以得出的关系就是：Hn=Hn-1
x 2 + 1.其实当我们得出这个算式的时候，稍微聪明一点的人已经明白，这就是一个递推公式，可以直接用此公式得出Hn的通解。但是LZ比较笨，就是不明白，为什么这个公式就可以套用呢？那么就干脆继续思考吧。让我们再想象一个情景：最大那个盘子在刚刚从A针被移动到C针，而那坨N-1个盘子还在B针蠢蠢欲动地等待着，即处于（中）->(后)的这个状态。怎么移动这N-1个盘子呢？其实这时候，问题已经回到了笔者标示“||：”符号的地方。“||：”是乐谱中的反复记号，而我们要做的，就是重复上面的步骤，但是要将N替换为N-1，因为现在只剩下N-1个盘子需要移动。而中转站则从B变成了A（鉴于这时盘子都在B针）。目标仍然是C针。下一次重复的时候，只剩下N-2个盘子需要移动，中转站又回到A，目标不变仍然是C针。……整个过程中，变化的只是中转站（在A与B之间轮换），以及剩下那些所需要移动的盘子的总数（越来越少）而已。那么那个大盘子怎么办？不去管它吗？？正解！！因为你已经把它移到C针，已经完成了这个移动步骤，它不会影响之后的操作。提醒自己牢记游戏规则，大盘子永远在小盘子下面，而你也不需要再重复移动它——“不重复移动”，正是游戏规则的要求！于是
Hn=Hn-1 x 2 + 1 这个公式，就可以套用、套用、套用……直到H3=7，H2=3，H1=1。最后，用最懒的数学归纳法证明通项公式
Hn = 2^n - 1 吧！没办法，LZ就是比较懒嘛~
