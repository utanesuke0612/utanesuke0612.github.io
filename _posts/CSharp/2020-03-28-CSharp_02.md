---
layout: post
title: C#入门经典第6章至第10章
date: 2020-05-27 01:02:01
categories: CSharp
tags: CSharp
---
* content
{:toc}

参考[西安交大-C#程序设计](https://www.icourse163.org/course/XJTU-1002843011)

# 1. 函数

本章主要内容：
1. 如何定义及使用，既不接收数据也不返回值的简单函数
2. 如何在函数传入传出数据
3. 使用变量作用域
4. 如何结合使用Main函数和命令行函数
5. 如何把函数提供为结构类型成员
6. 如何使用函数重载
7. 使用使用委托

除了第7以外的概念，都是理解的。

## 1.1 定义和使用函数

- 参数数组

C#运行指定给一个特殊参数，这个参数必须是函数定义的最后一个参数，称为参数数组，允许使用个数不定的参数调用数组，使用`params`关键字定义它们。
> Python中也有类似用法

```csharp
namespace ConsoleApp1
{
    class Program
    {

        static int Sumvals(params int[] vals)
        {
            int sum = 0;
            foreach (int val in vals)
            {
                sum += val;
            }
            return sum;
        }

        static void Main(string[] args)
        {
            int sum = Sumvals(1, 3, 4, 4);

            WriteLine($"Summed Values = {sum}");
            ReadKey();

        }
    }
}
```

上面代码中直接使用了WriteLine和Readkey，因为添加了`using static System.Console;`。

- 引用参数和值参数

使用参数时，通过引用传递参数，即函数处理的变量与函数调用中使用的变量相同，对这个变量进行的修改，会影响原来的参数，需要使用`ref`关键字来指定参数。

但是使用ref，必须有两个限制：
- 只能针对非常量，如果针对const变量，那是非法的。
- 必须使用初始化过的变量。

```csharp
namespace ConsoleApp1
{
    class Program
    {
        static void ShowDouble(ref int val) {
            val *= 2;
            WriteLine($"val doubled = {val}");
        }
        static void Main(string[] args)
        {
            int sum = 5;
            WriteLine($"original = {sum}");
            ShowDouble(ref sum);
            ReadKey();
        }
    }
}
```

输出：
original = 5
val doubled = 10

- 输出参数

除了按引用传递值外，还可以使用out关键字，指定所给的参数时一个输出参数。但是与引用ref有下面的区别：
- 可以把未赋值的变量用作out参数
- 函数在会使用out参数时，必须把他看成未赋值。

即使把已赋值的变量用作out参数，但存储在该变量的值会在函数执行时丢失。
因为out的值，是用于输出的，所以原始值有与没有都无所谓。


示例代码：

```csharp
    class Program
    {
        static int MaxValue(int[] intArray, out int maxIndex) {
            int maxVal = intArray[0];
            maxIndex = 0;
            for (int i = 1; i < intArray.Length; i++) {
                if (intArray[i] > maxVal) {
                    maxVal = intArray[i];
                    maxIndex = i;
                }
            }
            return maxVal;
        }
        static void Main(string[] args)
        {
            int[] myArray = { 1, 2, 3, 4, 5, 3, 3, 3, 7, 1, 1 };
            int maxIndex;
            WriteLine($"Max is : {MaxValue(myArray,out maxIndex)}");
            WriteLine($"index is in : {maxIndex+1}");
            ReadKey();
        }
    }
}
```

输出如下：

```
Max is : 7
index is in : 9
```

注意：
- out的参数，必须在该函数中再次赋值，否则编译出错
- out参数可以放多个，用法一样。

## 1.2 变量作用域

- 局部变量：作用域覆盖一个函数的变量
- 全局变量：作用域覆盖多个函数的变量，必须使用static或const关键字来定义这种形式的全局变量，static可修改，const禁止修改变量的值。

```csharp
namespace ConsoleApp1
{
    class Program
    {
        static string myString;

        static void Write() {
            string myString = "defined in write()";
            WriteLine("Now in Write()");
            WriteLine($"Local myString = {myString}");
            WriteLine($"Global myString = {Program.myString}");
            
        }

        static void Main(string[] args)
        {
            string myString = "define in Main()";
            Program.myString = "Global String";
            Write();

            WriteLine($"\n Now in Main()");
            Program.myString = "Global String2";
            WriteLine($"Local myString = {myString}");
            WriteLine($"Global myString = {Program.myString}");

            ReadKey();
        }
    }
}
```

输出：

```
Now in Write()
Local myString = defined in write()
Global myString = Global String

 Now in Main()
Local myString = define in Main()
Global myString = Global String2
```
- 如果将上面的static，修改为const，则会发生编译错误。
- 另外，可以看到`Program.myString`，通过类名来引用这个变量的，就是说这个变量是所有类共通的。


示例：

```csharp
    class Program
    {
        static void ShowDouble(ref int val) {

            val *= 2;
            WriteLine($"val doubled = {val}");
        }

        static void Main(string[] args)
        {
            int val = 5;
            WriteLine($"val = {val}");

            ShowDouble(ref val);

            WriteLine($"val = {val}");
            
            ReadKey();
        }
    }
```

输出：

```
val = 5
val doubled = 10
val = 10
```

通过下面的代码也可以得到同样的结果，一个是通过传入引用参数，一个是使用类的全局变量。

```csharp
namespace ConsoleApp1
{
    class Program
    {
        static int val;
        static void ShowDouble()
        {
            val *= 2;
            WriteLine($"val doubled = {val}");
        }

        static void Main(string[] args)
        {
            val = 5;
            WriteLine($"val = {val}");

            ShowDouble();

            WriteLine($"val = {val}");

            ReadKey();
        }
    }
}
```

## 1.3 Main()函数

Main()是C#应用程序的入口点，可以返回void,int,有一个可选参数`string[] args`:

```
static void Main()
static void Main(string[] args)
static int Main()
static int Main(string[] args)
```

1. 一般情况下，返回0表示正常终止。
2. 可选参数args是从应用程序的外部接收信息的方法。

有两种方式可以设定外部接收信息：

- 在IDE工具studio中设定，项目属性页面，即Properties页面中，选择debug页面，在Command line arguments中设置命令行参数。

![image](https://user-images.githubusercontent.com/18595935/78467887-b2404e00-774c-11ea-9b3c-f8dc902ecc1a.png)

```csharp
namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            WriteLine($"{args.Length}");
            foreach (string arg in args)
                WriteLine(arg);
            ReadKey();
        }
    }
}
```

输出如下：

```
4
hello
li utane
li utansuke
124
```

- 在项目输出所在的目录`\bin\debug`中打开命令提示窗口，输入如下代码，也可以得到同样的结果：

```
ConsoleApp1 hello "li utane" "li utansuke" 124
```

注意如果参数有空格，需要双引号将参数括起来。

## 1.4 结构函数

除了数据，结构中还可以包含函数，如下代码，定义了结构函数`Name()`:

```csharp
namespace ConsoleApp1
{
    struct CustomerName {
        public string firstname, lastname;
        public string Name() => firstname + " " + lastname;
    }
    class Program
    {
        static void Main(string[] args)
        {
            CustomerName myCustomer;
            myCustomer.firstname = "li";
            myCustomer.lastname = "utane";
            WriteLine(myCustomer.Name());

            ReadKey();
        }
    }
}
```

## 1.5 函数的重载

函数的重载与其他语言中概念一样，同一个函数名，但是包含的参数类型或个数不同，这样重载，比如如下的代码：

```csharp
namespace ConsoleApp1
{
    class Program
    {
        static int MaxValue(int[] intArray)
        {
            int maxVal = intArray[0];
            for (int i = 1; i < intArray.Length; i++)
            {
                if (intArray[i] > maxVal)
                    maxVal = intArray[i];
            }
            return maxVal;
        }

        static double MaxValue(double[] doubleArray)
        {
            double maxVal = doubleArray[0];
            for (int i = 1; i < doubleArray.Length; i++)
            {
                if (doubleArray[i] > maxVal)
                    maxVal = doubleArray[i];
            }
            return maxVal;
        }
        static void Main(string[] args)
        {
            int[] myArray = { 1, 2, 3, 5, 3, 3, 33, 99 };
            int maxVal = MaxValue(myArray);
            WriteLine($"Max: is {maxVal}");
            
            double[] mydoubleArray = { 1.1, 2.1, 3.2, 5.2, 3.2, 3.2, 3.3, 19.24 };
            double maxdoubleVal = MaxValue(mydoubleArray);
            WriteLine($"Max: is {maxdoubleVal}");


            ReadKey();
        }
    }
}
```

```
Max: is 99
Max: is 19.24
```


## 1.6 委托

委托是一个比较新的概念，以前没有学习过，关于委托，更多介绍在第13章。

1. 委托delegate是一种存储函数引用的类型。
2. 委托最重要的用途在本书后面的事件和事件处理时使用。
3. 委托的声明非常类似于函数，但不带函数体，要使用`delegate`关键字，委托的声明指定了一个返回类型和一个参数列表。

```csharp
namespace ConsoleApp1
{
    class Program
    {
        delegate double ProcessDelegate(double param1, double param2);
        static double Multiply(double param1, double param2) => param1 * param2;
        static double Divide(double param1, double param2) => param1 / param2;

        static void Main(string[] args)
        {
            ProcessDelegate process;
            WriteLine("Enter 2 number separated with a comma:");
            string input = ReadLine();
            int commaPos = input.IndexOf(",");
            double param1 = Convert.ToDouble(input.Substring(0, commaPos));
            double param2 = Convert.ToDouble(input.Substring(commaPos + 1,
                input.Length - commaPos - 1));

            WriteLine("Enter M to multipy or D to divide:");
            input = ReadLine();

            if (input == "M")
                process = new ProcessDelegate(Multiply);
            else
                process = new ProcessDelegate(Divide);

            WriteLine($"Result : {process(param1, param2)}");

            ReadKey();

        }
    }
}
```

```csharp
Enter 2 number separated with a comma:
1,2.3
Enter M to multipy or D to divide:
D
Result : 0.434782608695652
```

```csharp

```

## 1.7 练习


- 2. 使用两个命令行参数，分别把值放在字符串和整形变量中，然后显示这些值：

```csharp
namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            string myfirst = args[0];
            int myint = Convert.ToInt32(args[1]);
            WriteLine($"{myfirst} and {myint}");
            ReadKey();

        }
    }
}
```

- 3. 创建一个委托，在请求用户输入时，使用它模拟Console.ReadLine()函数

```csharp
namespace ConsoleApp1
{
    class Program
    {
        delegate string ReadLineDelegate(); 

        static void Main(string[] args)
        {
            ReadLineDelegate readLine = new ReadLineDelegate(ReadLine);
            WriteLine("Type a string");

            string userInput = readLine();
            WriteLine($"You typed : {userInput}");

            ReadKey();

        }
    }
}
```

输出：

```
Type a string
没有
You typed : 没有
```

## 1.8 要点：

1. 函数的名称和参数统称为函数签名，名称相同但签名不同的多个函数，这称为函数重载。
2. 个数不定的特定类型参数，可以用参数数组指定，`params int[] args`，放在参数列表最后面。
3. 参数可以指定ref或out，以便给调用者返回值，调用函数时也必须包括对应的ref和out关键字。
4. 委托：除了直接调用函数外，还可以通过委托调用他们，具体见上面。

# 2. 调试和错误处理

> 暂时跳过，需要时再看

# 3. 面向对象编程

## 3.1 面向对象编程的含义

## 3.2 OOP技术 - 接口

## 3.3 OOP技术 - 继承

## 3.4 OOP技术 - 多态性

## 3.5 OOP技术 - 对象之间的关系

## 3.6 OOP技术 - 运算符重载

## 3.7 OOP技术 - 事件

## 3.8 OOP技术 - 引用类型和值类型

## 3.9 桌面应用程序中的OOP

## 3.10 联系

## 3.11 本章要点

# 4. 定义类

# 5. 定义类成员

