---
layout: post
title: Nano01(自動運転)-U03-Lesson13-Deep Neural Networks深度神经网络
date: 2019-01-01 02:03:04
categories: self-driving(自動運転)
tags: self-driving
---
* content
{:toc}

# 3. Number of Parameters

计算下面网络中的参数个数：

![image](https://user-images.githubusercontent.com/18595935/52047828-374e3700-258d-11e9-9ea8-2440bb25f38b.png)

上面的参数，有权重和偏置，权重(input,label)，偏置(label,)

```
= size of W + size of b
= 28x28x10 + 10
= 7850
```

可以参考如下代码：

```python
n_features = 3
n_labels = 5
weights = tf.Variable(tf.truncated_normal((n_features, n_labels)))
bias = tf.Variable(tf.zeros(n_labels))
```

# 7. 2-Layer Neural Network

![image](https://user-images.githubusercontent.com/18595935/52048269-4ed9ef80-258e-11e9-8f91-c30cb72986df.png)
> ReLU 是个非线性函数，当x大于0时，y等于x；否则y为0，该函数的导数如下图：
> ![image](https://user-images.githubusercontent.com/18595935/52048364-906a9a80-258e-11e9-9027-140ea2fa6041.png)

1. 第一层由输入x和其对应的权重w及偏置bias构成，结果经由ReLU函数，传递给下一层神经网络。
2. 第二层由上一层的中间结果，以及该层的权重w和偏置bias构成，计算出来的结果，最终传递给激活函数如softmax函数，计算出概率。

# 8. Quiz: TensorFlow ReLu

ReLU函数(f(x) = max(0, x))，也是一种激活函数，它在TensorFlow中用` tf.nn.relu()`来定义，示例代码如下：

```python
# Hidden Layer with ReLU activation function
hidden_layer = tf.add(tf.matmul(features, hidden_weights), hidden_biases)
hidden_layer = tf.nn.relu(hidden_layer)

output = tf.add(tf.matmul(hidden_layer, output_weights), output_biases)
```

上面的代码：

1. 将 tf.nn.relu() 应用到了 hidden_layer 隐藏层。
2. 添加了一个新的层output layer，output layer的输入数据是前一层hidden_layer的输出(非线性Relu函数处理后的)

In this quiz, you'll use TensorFlow's ReLU function to turn the linear model below into a nonlinear model.

代码如下：

```python
# Solution is available in the other "solution.py" tab
import tensorflow as tf

output = None
hidden_layer_weights = [
    [0.1, 0.2, 0.4],
    [0.4, 0.6, 0.6],
    [0.5, 0.9, 0.1],
    [0.8, 0.2, 0.8]]
out_weights = [
    [0.1, 0.6],
    [0.2, 0.1],
    [0.7, 0.9]]

# Weights and biases
weights = [
    tf.Variable(hidden_layer_weights),
    tf.Variable(out_weights)]
biases = [
    tf.Variable(tf.zeros(3)),
    tf.Variable(tf.zeros(2))]

# Input
features = tf.Variable([[1.0, 2.0, 3.0, 4.0], [-1.0, -2.0, -3.0, -4.0], [11.0, 12.0, 13.0, 14.0]])
```

```python
# TODO: Create Model
hidden_layer = tf.add(tf.matmul(features, weights[0]), biases[0])

hidden_layer = tf.nn.relu(hidden_layer)

output  = tf.add(tf.matmul(hidden_layer, weights[1]), biases[1])
```

```python
# TODO: save and print session results on a variable named "output"

init = tf.global_variables_initializer()

with tf.Session() as sess:
    # Run the tf.constant operation in the session
    sess.run(init)
    result = sess.run(output)
    print(result)
```

输出结果如下：

```
[[  5.11000013   8.44000053]
 [  0.           0.        ]
 [ 24.01000214  38.23999786]]
```

# 11. Backprop 反向传播

![image](https://user-images.githubusercontent.com/18595935/52112744-cc633580-264a-11e9-91f8-6c99db2e874f.png)

这部分就是[误差反向传播法](http://road2ai.info/2018/07/28/Deeplearning_05/)的内容，详细要参考这里。

# 12. Deep Neural Network in TensorFlow

## 12.1 示例代码：

```python
from tensorflow.examples.tutorials.mnist import input_data
mnist = input_data.read_data_sets(".", one_hot=True, reshape=False)

import tensorflow as tf

# Parameters
learning_rate = 0.001
training_epochs = 20
batch_size = 128  # Decrease batch size if you don't have enough memory
display_step = 1

n_input = 784  # MNIST data input (img shape: 28*28)
n_classes = 10  # MNIST total classes (0-9 digits)

n_hidden_layer = 256 # layer number of features

# Store layers weight & bias
weights = {
    'hidden_layer': tf.Variable(tf.random_normal([n_input, n_hidden_layer])),
    'out': tf.Variable(tf.random_normal([n_hidden_layer, n_classes]))
}
biases = {
    'hidden_layer': tf.Variable(tf.random_normal([n_hidden_layer])),
    'out': tf.Variable(tf.random_normal([n_classes]))
}

# tf Graph input
x = tf.placeholder("float", [None, 28, 28, 1])
y = tf.placeholder("float", [None, n_classes])

x_flat = tf.reshape(x, [-1, n_input])

# Hidden layer with RELU activation
layer_1 = tf.add(tf.matmul(x_flat, weights['hidden_layer']), biases['hidden_layer'])
layer_1 = tf.nn.relu(layer_1)
# Output layer with linear activation
logits = tf.matmul(layer_1, weights['out']) + biases['out']

# Define loss and optimizer
cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=y))
optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate).minimize(cost)

# Initializing the variables
init = tf.global_variables_initializer()

# Launch the graph
with tf.Session() as sess:
    sess.run(init)
    # Training cycle
    for epoch in range(training_epochs):
        total_batch = int(mnist.train.num_examples/batch_size)
        # Loop over all batches
        for i in range(total_batch):
            batch_x, batch_y = mnist.train.next_batch(batch_size)
            # Run optimization op (backprop) and cost op (to get loss value)
            sess.run(optimizer, feed_dict={x: batch_x, y: batch_y})
        # Display logs per epoch step
        if epoch % display_step == 0:
            c = sess.run(cost, feed_dict={x: batch_x, y: batch_y})
            print("Epoch:", '%04d' % (epoch+1), "cost=", \
                "{:.9f}".format(c))
    print("Optimization Finished!")

    # Test model
    correct_prediction = tf.equal(tf.argmax(logits, 1), tf.argmax(y, 1))
    # Calculate accuracy
    accuracy = tf.reduce_mean(tf.cast(correct_prediction, "float"))
    # Decrease test_size if you don't have enough memory
    test_size = 256
    print("Accuracy:", accuracy.eval({x: mnist.test.images[:test_size], y: mnist.test.labels[:test_size]}))

```

## 12.2 代码解析

- 使用TensorFlow提供的MNIST数据，已经做好了batch和one-hot编码处理：

```python
from tensorflow.examples.tutorials.mnist import input_data
mnist = input_data.read_data_sets(".", one_hot=True, reshape=False)
```

- Learning Parameters

定义各类超参数：

```python
import tensorflow as tf

# Parameters
learning_rate = 0.001
training_epochs = 20
batch_size = 128  # Decrease batch size if you don't have enough memory
display_step = 1

n_input = 784  # MNIST data input (img shape: 28*28)
n_classes = 10  # MNIST total classes (0-9 digits)
```

- Hidden Layer Parameters

定义隐藏层上的神经元数量：

```python
n_hidden_layer = 256 # layer number of features
```

- Weights and Biases 权重和偏置

这里只有两层神经网络，所有只有hidden_layer和out的权重及偏置

```python
# Store layers weight & bias
weights = {
    'hidden_layer': tf.Variable(tf.random_normal([n_input, n_hidden_layer])),
    'out': tf.Variable(tf.random_normal([n_hidden_layer, n_classes]))
}
biases = {
    'hidden_layer': tf.Variable(tf.random_normal([n_hidden_layer])),
    'out': tf.Variable(tf.random_normal([n_classes]))
}
```

- input 输入数据

```python
# tf Graph input
x = tf.placeholder("float", [None, 28, 28, 1])
y = tf.placeholder("float", [None, n_classes])

x_flat = tf.reshape(x, [-1, n_input])
```

需要将28*28的单通道数据([None, 28, 28, 1])，通过reshape转换成一行数据，一行中有784个像素点数据。

- Multilayer Perceptron 多层感知

![image](https://user-images.githubusercontent.com/18595935/52113676-544a3f00-264d-11e9-8f97-80ba7a22edc8.png)

下面代码先计算xW+b，然后将其传递给ReLU层，最后传递给下一个xW+b，得到最后的logits layer：

```python
# Hidden layer with RELU activation
layer_1 = tf.add(tf.matmul(x_flat, weights['hidden_layer']),\
    biases['hidden_layer'])
layer_1 = tf.nn.relu(layer_1)
# Output layer with linear activation
logits = tf.add(tf.matmul(layer_1, weights['out']), biases['out'])
```

- Optimizer 优化器

```python
# Define loss and optimizer
cost = tf.reduce_mean(\
    tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=y))
optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)\
    .minimize(cost)
```

-  session

TensorFlow中提供的MNIST library库，能够批量接收数据集，使用`mnist.train.next_batch()`函数返回训练数据的一个子集subset。

```python
# Initializing the variables
init = tf.global_variables_initializer()

# Launch the graph
with tf.Session() as sess:
    sess.run(init)
    # Training cycle
    for epoch in range(training_epochs):
        total_batch = int(mnist.train.num_examples/batch_size)
        # Loop over all batches
        for i in range(total_batch):
            batch_x, batch_y = mnist.train.next_batch(batch_size)
            # Run optimization op (backprop) and cost op (to get loss value)
            sess.run(optimizer, feed_dict={x: batch_x, y: batch_y})
```

# 13. Training a Deep Learning Network
