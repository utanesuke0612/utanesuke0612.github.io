---
layout: post
title: Nano01(自動運転)-U02-Lesson07-Camera Calibration
date: 2018-08-11 01:02:03
categories: self-driving(自動運転)
tags: self-driving
---
* content
{:toc}

# 1. Welcome to Computer Vision

Robotics can essentially be broken into a three step cycle.
1. To sense or perceive the world.
2. To decide what to do based on that perception.
3. To perform an action to carry out that decision.

即感知，决策和执行三个步骤，computer vision is a major part of the perception step in that cycle.
> 80% of building a self-driving car is perception.

Later in the nano degree project, we will be using laser and radar data for the task of perception.

![image](https://user-images.githubusercontent.com/18595935/49733943-33591380-fcc6-11e8-8d5b-ca5a055615a0.png)

# 3. Overview

本章中要写一个更好的车道线定位算法，使得它可以处理弯曲的车道线，适应阴影和路面颜色的变化。
- 测量车道线的弯曲程度。
- 车辆与道路中心的相对位置。

在这之后，需要实现车辆检测与跟踪，在决定何时改变车道，何时加速，以及何时停止时，都需要知道其他车的位置。

本project分为两个部分:
1. 车道线识别进阶
2. 车辆检测与跟踪
最后把这两个项目结合起来，判断车辆在道路上的位置道路走向，以及视野中其他车的位置。

# 4. Getting Started

最终目标是测量控制汽车必需的一些数据，比如测量车道线的弯曲程度，需要：
- 在照片中定位出车道线的位置
- 然后通过透视变换，转换车道线视角

为了获得正确的视角，首先要纠正图像失真(比如图片的扭曲)

# 5. Distortion Correction

Image Distortion: 将真实世界的三维图片转换成二维时的变形，这种转换并不是完美的。

![image](https://user-images.githubusercontent.com/18595935/49733954-3c49e500-fcc6-11e8-9663-96b928c35c99.png)

我们的最终目标是根据Lane的曲率去判断驾驶方向等，如果车道失真，我们就会得到错误的曲率，那么转向角度也会有问题。

所以处理图像的第一步工作，就是消除失真，这样才能从图像中获取有用的信息。

# 7. Pinhole Camera Model 针眼相机模式
## 7.1 Types of Distortion

- **radial distortion** 径向畸变
相机的镜头通常都是弧线的，光线通过弧线时会发生扭曲。
实际为直线的物体，会变得像曲线一样。
Real cameras use curved lenses to form an image, and light rays often bend a little too much or too little at the edges of these lenses. This creates an effect that distorts the edges of images, so that lines or objects appear more or less curved than they actually are。

![image](https://user-images.githubusercontent.com/18595935/49733982-4966d400-fcc6-11e8-9168-834d1993071a.png)

实际物体，经过镜头的变换，会从3D转换到2D。
经过转换后，在镜头边缘的图像会发生变形，效果如下：

![image](https://user-images.githubusercontent.com/18595935/49733989-4c61c480-fcc6-11e8-9148-7a42b35eb787.png)


- **tangential distortion** 切向畸变
当镜头与摄像机胶片并不平行时，会导致物体看起来更远或是更近，距离不准确。
This occurs when a camera’s lens is not aligned perfectly parallel to the imaging plane, where the camera film or sensor is. This makes an image look tilted so that some objects appear farther away or closer than they actually are.
如鱼眼镜头或广角镜头，就是故意达到这种效果。

## 7.2 Distortion Coefficients and Correction 畸变系数和校正

通过调整后：

![image](https://user-images.githubusercontent.com/18595935/49734015-5aafe080-fcc6-11e8-9b30-5dd6a00cb24c.png)

# 9. Measuring Distortion

# 10. Finding Corners

使用如下的两个函数，找到和画出棋盘的角落。
- cv2.findChessboardCorners() 
- cv2.drawChessboardCorners()

In the following exercise, your job is simple. Count the number of corners in any given row and enter that value in nx. Similarly, count the number of corners in a given column and store that in ny. Keep in mind that "corners" are only points where two black and two white squares intersect, in other words, only count inside corners, not outside corners.

```python
import numpy as np
import cv2
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# prepare object points
nx = 8#TODO: enter the number of inside corners in x
ny = 6#TODO: enter the number of inside corners in y

# Make a list of calibration images
fname = 'calibration_test.png'
img = cv2.imread(fname)

# Convert to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Find the chessboard corners
ret, corners = cv2.findChessboardCorners(gray, (nx, ny), None)

# If found, draw corners
if ret == True:
    # Draw and display the corners
    cv2.drawChessboardCorners(img, (nx, ny), corners, ret)
    plt.imshow(img)
```

输出结果为:

![image](https://user-images.githubusercontent.com/18595935/49734030-626f8500-fcc6-11e8-99b0-d596bf6ab7ca.png)

# 11. 【重要:有详细的原理讲解】Calibrating Your Camera

1. 读取图形
2. 新建校正前坐标，与校正后坐标的数组
3. 将图像转换成灰度图，并使用`findChessboardCorners`查找棋盘角点
4. 将检测到的角点，添加到图像点的数组中
5. 使用`drawChessboardCorners`函数，描绘出棋盘角点
6. 重复上述的步骤，处理其他的图形

下面讲解进行镜头校准和最终图像去畸变所涉及到的函数:
- `cv2.calibrateCamera(objpoints,imgpoints,gray.shape[::-1],None,None)`，通过输入原始图像的坐标，校正后图形坐标，形状信息，处理后其return为`Return values:ret,mtx,dist,rvecs,tvecs`，dist是失真系数，以及镜头在真实环境中的位置
- `dst = cv2.undistort(img,mtx,dist,None,mtx)`，该函数接收一副畸变的图像镜头矩阵和失真系数，返回去除畸变后的图像，通常称为目标图形


# 12. Correcting for Distortion

There are two main steps to this process: 
- use chessboard images to obtain image points and object points, 
- and then use the OpenCV functions cv2.calibrateCamera() and cv2.undistort() to compute the calibration and undistortion.

参考代码:

```python
import pickle
import cv2
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# Read in the saved objpoints and imgpoints
dist_pickle = pickle.load( open( "wide_dist_pickle.p", "rb" ) )
objpoints = dist_pickle["objpoints"]
imgpoints = dist_pickle["imgpoints"]

# Read in an image
img = cv2.imread('test_image.png')

# TODO: Write a function that takes an image, object points, and image points
# performs the camera calibration, image distortion correction and 
# returns the undistorted image
def cal_undistort(img, objpoints, imgpoints):
    # Use cv2.calibrateCamera() and cv2.undistort()
    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)
    #undist = np.copy(img)  # Delete this line
    undist = cv2.undistort(img, mtx, dist, None, mtx)
    return undist

undistorted = cal_undistort(img, objpoints, imgpoints)

f, (ax1, ax2) = plt.subplots(1, 2, figsize=(24, 9))
f.tight_layout()
ax1.imshow(img)
ax1.set_title('Original Image', fontsize=50)
ax2.imshow(undistorted)
ax2.set_title('Undistorted Image', fontsize=50)
plt.subplots_adjust(left=0., right=1, top=0.9, bottom=0.)
```

处理后的图像对比如下:

![image](https://user-images.githubusercontent.com/18595935/49734043-6ef3dd80-fcc6-11e8-8dbe-ac5780b0d90a.png)


# 13. Lane Curvature 车道曲率[跟高精度地图相关★重要]

> 本节重要，需要自己去拓展，什么是透视变换，设么是多项式拟合，如何变换如何拟合等，都需要调查！！

学习如何从公路图像中提取有效信息，其中一项重要内容就是车道曲率，无人车需要知道转向角大小，才能左拐或右拐。如果我们知道汽车的速度和形式状态，以及车道的弯曲程度，就可以计算这个角度。

- 先使用掩码和阈值化技术，检测出车道线。即Project1中的相关技术。

![image](https://user-images.githubusercontent.com/18595935/49734079-803cea00-fcc6-11e8-8223-ce3e83a73083.png)


- 然后进行透视变换，以获得车道的鸟瞰图。
- 然后使用多项式进行车道线拟合。

![image](https://user-images.githubusercontent.com/18595935/49734093-8af77f00-fcc6-11e8-9577-676f0d6a38ee.png)

For a lane line that is close to vertical, you can fit a line using this formula: f(y) = Ay^2 + By + C, where A, B, and C are coefficients.

- A gives you the curvature of the lane line
- B gives you the heading or direction that the line is pointing,
- C gives you the position of the line based on how far away it is from the very left of an image (y = 0).

# 14. Perspective Transform-透视变换

透视变换，是图像中的一种现象，物体距离观察点(例如镜头)越远，看起来就越小，平行的直线在最远处汇聚成同一个点上。

下面的左图中，是一般的摄像头视角，两条平行的线汇聚成一个点，经过透视变换后，两条线实际是平行的，其曲率是向右。

![image](https://user-images.githubusercontent.com/18595935/49734118-99459b00-fcc6-11e8-9f19-d93d8de64176.png)

透视变换可以让我们改变视角，通过不同的视点和角度观察相同的场景。

![image](https://user-images.githubusercontent.com/18595935/49734129-a2cf0300-fcc6-11e8-834c-475413830d59.png)

透视变换，与图像去畸变的方法类似，但是:

- 去畸变：将对象点映射到图像点

- 透视变换：将给定的图像点映射到一个新视角下的图像点

![image](https://user-images.githubusercontent.com/18595935/49734153-ba0df080-fcc6-11e8-930f-70b528b1bb42.png)

We want to measure the curvature of the lane, and to do that we first need to transform to a top-down view of the lane.

# 16. Transform a Stop Sign

将侧面视角拍摄的图片，通过变换变成正面视角的图像。

对公路图像进行透视变换，从而帮助得到车道线曲率。

![image](https://user-images.githubusercontent.com/18595935/49874347-9c28c300-fe61-11e8-9e9d-b9513be5f546.png)

为进行透视变换，我们需要首先选择四个点,这些点定义了一个长方形，位于这幅图像的同一平面，四个点就足以确定从一种视角到另一种视角的线性变换了。

下面的例子中，
- 我们选择若干点来定义停车标志表面的一个平面
- 另外还需要选择这四个点在变换后出现的位置，变换之后的图像称为扭转图像(warped image)
- 使用openCV函数计算这种变换，这种变换将原始图像中的点，映射到不同视角下的扭转图像中

![image](https://user-images.githubusercontent.com/18595935/49874818-da72b200-fe62-11e8-90e0-c9c2d6e12e3d.png)

**示例代码如下:**

```python

```

**代码介绍：**

- 计算透视变换 M，输入参数为 source points 和 destination points

```python
M = cv2.getPerspectiveTransform(src, dst)
```

- 计算你想的透视变换:

```python
Minv = cv2.getPerspectiveTransform(dst, src)
```

- 使用M对图像进行扭曲处理

```python
warped = cv2.warpPerspective(img, M, img_size, flags=cv2.INTER_LINEAR)
```


