---
layout: post
title:  Git教程(廖雪峰)
date:   2019-02-16 01:02:00
categories: 其他
tags:
---
* content
{:toc}

感谢廖老师出品[Git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)，浅显易懂。

# 0. 总结

1. 初始化一个Git仓库：`git init`
2. 添加文件到Git仓库step1：`git add <file>`
3. 添加文件到Git仓库step2：`git commit -m <message>`
4. 要随时掌握工作区的状态，使用：`git status`
5. 如果git status告诉你有文件被修改过，用：`git diff`查看修改内容
6. `HEAD`指向的版本就是当前版本，因此可以在各个版本之间穿梭，`git reset --hard eb69 (回到eb69版本)`，或`git reset --hard HEAD^ (回退到前一个版本)`
7. 穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本，或是简介版`git log --pretty=oneline`
8. 要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本
9. 查看当前仓库版本，与工作区版本的差别：`git diff HEAD -- readme.txt`
10. 丢弃工作区的修改时，用命令: `git checkout -- readme.txt`
11. 丢弃暂存区的修改，用命令:`git reset HEAD readme.txt`
12. 删除暂存区的文件，`git rm`，与`git add`一样地位的命令，然后`git commit`提交到仓库
13. 本地创建SSH Key，`ssh-keygen -t rsa -C "lijun.kawasaki@gmail.com"`
14. 要关联一个远程库，使用命令：`git remote add origin https://github.com/utanesuke0612/learngit.git`
15. 关联后，使用命令：`git push -u origin master`第一次推送master分支的所有内容
16. 每次本地提交后，使用：`git push origin master`推送最新修改
17. 用命令`git clone https://github.com/utanesuke0612/udacitystudy.git`克隆一个远程库到本地
18. 查看分支：`git branch`
19. 创建分支：`git branch <name>`
20. 切换分支：`git checkout <name>`
21. 创建+切换分支：`git checkout -b <name>`
22. 合并某分支到当前分支：`git merge <name>``
23. 删除分支：`git branch -d <name>`
24. 如果两个不同分支上，针对同一个文件进行了修改，在合并分支的时候，可能会出现合并冲突，这时候要手动解决冲突，然后再添加并提交。
25. 通过`git log --graph`命令可以看到分支合并图。
26. 通过这种方式merge，能够保留分支上的信息，`git merge --no-ff -m "merge with no-ff" dev`
27. 通过 `git log --graph --pretty=oneline --abbrev-commit`  查看分支历史
28. 当手头工作没有完成时，先把工作现场`git stash `一下，然后去修复bug，修复后，再 `git stash pop `，回到工作现场。
29. 开发一个新feature，最好新建一个分支
30. 如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。

# 1. Git简介

![image](https://user-images.githubusercontent.com/18595935/52925534-2bc48380-3375-11e9-9371-9db0ff0981fe.png)

## 1. 安装Git

**Linux：**

使用`$ git` 或`sudo apt-get install git`(Ubuntu)，

另外，MAC上通过XCode直接安装。

**Windows：**

直接官网下载安装，菜单中有 Git->Git Bash说明安装成功。

安装完成后，还需要最后一步设置，在命令行输入：

```c
$ git config --global user.name "utane"
$ git config --global user.email "lijun.kawasaki@gmail.com"
```

注意`git config`命令的`--global`参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置。

## 2. 创建版本库

这个目录里面所有文件都可以被Git管理，修改删除等都能跟踪，以便任何时候都能追踪历史和还原。

- 选择合适位置创建空目录：

```sh
utane@ubuntu:~$ mkdir learngit
utane@ubuntu:~$ cd learngit/
utane@ubuntu:~/learngit$ pwd
/home/utane/learngit
```

- 通过`git init`命令把这个目录变成Git可以管理的仓库：

```sh
utane@ubuntu:~/learngit$ git init
Initialized empty Git repository in /home/utane/learngit/.git/
```

通过下面的命令，可以看到创建了对应的目录，`.git`这个目录是Git来跟踪管理版本库的。

```sh
utane@ubuntu:~/learngit$ ls -ah
.  ..  .git
```

- 对应目录下添加文件

```sh
utane@ubuntu:~/learngit$ vim readme.txt
```

新建一个文件`readme.txt`并写入如下内容：

```
Git is a version control system.
Git is free software.
```

- step1:将文件添加到仓库`git add`：

```sh
utane@ubuntu:~/learngit$ git add readme.txt
```

- step2:把文件提交到仓库`git commit`：

```sh
utane@ubuntu:~/learngit$ git commit -m "wrote a readme file"
[master (root-commit) 4568339] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
utane@ubuntu:~/learngit$ 
```
# 2. 时光穿梭

现在我们来修改刚才的文件，添加一行：

```
Git is a version control system.
Git is free software.

add more @1st
```

运行`git status`可以查看仓库的当前状态：

```sh
utane@ubuntu:~/learngit$ git status
ブランチ master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

用`git diff`这个命令看看修改的内容：

```sh
utane@ubuntu:~/learngit$ git diff
diff --git a/readme.txt b/readme.txt
index 46d49bf..6c50b8d 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,4 @@
 Git is a version control system.
 Git is free software.
+
+add more @1st
```

后面就是相同的步骤：

- 用`git add`添加，这时用`git status`查看的话，可以知道将被提交的修改包括readme.txt

```sh
utane@ubuntu:~/learngit$ git add readme.txt
utane@ubuntu:~/learngit$ git status
ブランチ master
コミット予定の変更点:
  (use "git reset HEAD <file>..." to unstage)

	modified:   readme.txt
```

- 用`git commit`提交，在git status看到仓库是干净的：

```sh
utane@ubuntu:~/learngit$ git commit -m "add more 1st"
[master 0e6ec7c] add more 1st
 1 file changed, 2 insertions(+)
utane@ubuntu:~/learngit$ git status
ブランチ master
nothing to commit, working tree clean
```

## 2.1 版本回退

现在我们接着修改，然后add,commit，这样就有了这三个版本：

- version3：

```
Git is a version control system.
Git is free software.

add more @1st
add more @2nd
```

- version2：

```
Git is a version control system.
Git is free software.

add more @1st
```

- version1：

```
Git is a version control system.
Git is free software.
```

通过`git log`可以查看最近的版本：

```sh
utane@ubuntu:~/learngit$ git log
commit eb699b8393c236eabd4a0167c799e12ac70ff566 (HEAD -> master)
Author: utane <lijun.kawasaki@gmail.com>
Date:   Sun Feb 17 19:59:54 2019 -0800

    add more 2nd

commit 0e6ec7c49ebc91ecd9af68a5b0c5964fcbc12df2
Author: utane <lijun.kawasaki@gmail.com>
Date:   Sun Feb 17 19:53:56 2019 -0800

    add more 1st

commit 4568339df27afae26c50dd0d51d63c049429b6f5
Author: utane <lijun.kawasaki@gmail.com>
Date:   Sun Feb 17 19:21:21 2019 -0800

    wrote a readme file
```

上面显示的结果太繁琐，可以用`git log --pretty=oneline`输出更简洁的结果：

```sh
utane@ubuntu:~/learngit$ git log --pretty=oneline
eb699b8393c236eabd4a0167c799e12ac70ff566 (HEAD -> master) add more 2nd
0e6ec7c49ebc91ecd9af68a5b0c5964fcbc12df2 add more 1st
4568339df27afae26c50dd0d51d63c049429b6f5 wrote a readme file
```

前面一长串的是版本号。

首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个^比较容易数不过来，所以写成`HEAD~100`。

- 比如我们回退到第二个版本，就是上一个版本：

```sh
utane@ubuntu:~/learngit$ git reset --hard HEAD^
HEAD is now at 0e6ec7c add more 1st
utane@ubuntu:~/learngit$ cat readme.txt 
Git is a version control system.
Git is free software.

add more @1st
```

输出对应文件，可以看到文件回退了。

- 另外，还可以通过版本号回退，比如：

```sh
utane@ubuntu:~/learngit$ git reset --hard 4568
HEAD is now at 4568339 wrote a readme file
utane@ubuntu:~/learngit$ cat readme.txt 
Git is a version control system.
Git is free software.
```

回退到了第一个版本。

- 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？Git提供了一个命令`git reflog`用来记录你的每一次命令，找到对应的版本号后，又可以回到最新版本了。

```sh
utane@ubuntu:~/learngit$ git reflog
4568339 (HEAD -> master) HEAD@{0}: reset: moving to 4568
0e6ec7c HEAD@{1}: reset: moving to HEAD^
eb699b8 HEAD@{2}: commit: add more 2nd
0e6ec7c HEAD@{3}: commit: add more 1st
4568339 (HEAD -> master) HEAD@{4}: commit (initial): wrote a readme file
utane@ubuntu:~/learngit$ git reset --hard eb69
HEAD is now at eb699b8 add more 2nd
utane@ubuntu:~/learngit$ cat readme.txt 
Git is a version control system.
Git is free software.

add more @1st
add more @2nd
```

## 2.2 工作区和暂存区

Git和其他的不同之处就是有暂存区的概念。

### 1. 概念

**工作区 working directory：**

之前创建的工作目录，就是一个工作区，比如下面的`learngit`目录：

```sh
utane@ubuntu:~/learngit$ ls -ah
.  ..  .git  LICENSE  readme.txt
```

**版本库 Repository：**

注意上面，还有一个隐藏目录`.git`,这个不算工作区，而是Git的版本库，包含了：

- 称为stage的暂存区
- 还有Git自动创建的第一个分支 master
- 以及指向master的一个指针HEAD

```sh
utane@ubuntu:~/learngit/.git$ ls
COMMIT_EDITMSG  ORIG_HEAD  config       hooks  info  objects
HEAD            branches   description  index  logs  refs
```

![image](https://user-images.githubusercontent.com/18595935/52929237-edd05b00-3386-11e9-93ca-b356a85d47b6.png)

之前提到将文件往Git版本库添加时，分两步：
1. `git add` 把文件添加进去，实际上就是把文件修改添加到**暂存区**
2. `git commit` 提交更改，实际上就是把暂存区的所有内容提交到当前分支

### 2. 实践

- 先修改和添加文件：
	1. 修改之前readme.txt文件
	2. 添加一个新的文件LICENSE

```sh
utane@ubuntu:~/learngit$ vi readme.txt 
utane@ubuntu:~/learngit$ vi LICENSE
```

- 用`git status`查看状态，可以看到readme.txt被修改了，而LICENSE还无法被追踪

```sh
utane@ubuntu:~/learngit$ git status
ブランチ master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

追跡されていないファイル:
  (use "git add <file>..." to include in what will be committed)

	LICENSE

no changes added to commit (use "git add" and/or "git commit -a")
```

- 用`git add`添加这两个文件后，查看状态，可以看到这两个文件都是下一次的commit对象，因为这两个文件都被放到了stage暂存区：

```sh
utane@ubuntu:~/learngit$ git add readme.txt LICENSE 
utane@ubuntu:~/learngit$ git status
ブランチ master
コミット予定の変更点:
  (use "git reset HEAD <file>..." to unstage)

	new file:   LICENSE
	modified:   readme.txt
```


![image](https://user-images.githubusercontent.com/18595935/52929499-fecd9c00-3387-11e9-84e4-bdac519829e5.png)

- 最后用 git commit提交，查看status看到工作区是干净的了

```sh
utane@ubuntu:~/learngit$ git commit -m "uderstand stage:add license"
[master 87486c1] uderstand stage:add license
 2 files changed, 3 insertions(+)
 create mode 100644 LICENSE
utane@ubuntu:~/learngit$ git status
ブランチ master
nothing to commit, working tree clean
```

![image](https://user-images.githubusercontent.com/18595935/52929564-47855500-3388-11e9-970a-34b782d6e213.png)

## 2.3 管理修改

- 在readme.txt中继续添加一行 `add more @4th`

```sh
utane@ubuntu:~/learngit$ vim readme.txt 
utane@ubuntu:~/learngit$ cat readme.txt 
Git is a version control system.
Git is free software.

add more @1st
add more @2nd
add more @3rd
add more @4th
```

- 将上面添加了`add more @4th`的文件放入暂存区：

```sh
utane@ubuntu:~/learngit$ git add readme.txt 
```

- 继续添加行`add more @5th`，但是没有git add到暂存区。

- 将暂存区的commit：

```sh
utane@ubuntu:~/learngit$ git commit -m "git tracks changes"
[master 18de63f] git tracks changes
 1 file changed, 1 insertion(+), 1 deletion(-)
```

这时工作区的文件，是最新的状态：

```sh
utane@ubuntu:~/learngit$ cat readme.txt 
Git is a version control system.
Git is free software.

add more @1st
add more @2nd
add more @3rd
add more @4th
add more @5th
```

如果用git status查看，显示有修改没有被加到暂存区(因为第二次的 5th add more没有加到暂存区)，另外暂存区没有需要commit的：

```sh
utane@ubuntu:~/learngit$ git status
ブランチ master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

## 2.4 撤销修改

### 1. 撤销工作区的修改

如果在工作区进行了修改，但是还没有git add到暂存区，使用`git checkout -- file`可以丢弃工作区的修改。

- 工作区文件中追加了一行`stupid boss`

```sh
utane@ubuntu:~/learngit$ vi readme.txt 
utane@ubuntu:~/learngit$ cat readme.txt 
Git is a version control system.
Git is free software.

add more @1st
add more @2nd
add more @3rd
add more @4th
stupid boss

```

- `git status`查看其状态，反应工作区有文件修改了，还没有staged

```sh
utane@ubuntu:~/learngit$ git status
ブランチ master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

- `git checkout -- readme.txt`将工作区的修改撤销，可以看到最后一行消失了

```sh
utane@ubuntu:~/learngit$ git checkout -- readme.txt
utane@ubuntu:~/learngit$ 
utane@ubuntu:~/learngit$ cat readme.txt 
Git is a version control system.
Git is free software.

add more @1st
add more @2nd
add more @3rd
add more @4th
```

### 2. 撤销暂存区的修改

- 将readme.txt中添加一行`stupid boss`，并添加到暂存区，用git status查看，说明已经放到了暂存区，下一步可以commit。

```sh
utane@ubuntu:~/learngit$ vi readme.txt 
utane@ubuntu:~/learngit$ git add readme.txt 
utane@ubuntu:~/learngit$ git status
ブランチ master
コミット予定の変更点:
  (use "git reset HEAD <file>..." to unstage)

	modified:   readme.txt
```

- `git reset HEAD readme.txt`可以把暂存区的修改撤销掉（unstage），重新放回工作区：

```sh
utane@ubuntu:~/learngit$ git reset HEAD readme.txt
Unstaged changes after reset:
M	readme.txt
```

- 在查看仓库状态，看到暂存区没有文件可以commit，暂存区撤销成功了。

```sh
utane@ubuntu:~/learngit$ git status
ブランチ master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

- 进一步撤销工作区，撤销之后工作区就干净了

```sh
utane@ubuntu:~/learngit$ git checkout -- readme.txt
utane@ubuntu:~/learngit$ git status
ブランチ master
nothing to commit, working tree clean
utane@ubuntu:~/learngit$ cat readme.txt 
Git is a version control system.
Git is free software.

add more @1st
add more @2nd
add more @3rd
add more @4th
```

## 2.5 删除文件

- 添加一个文件，并commit到仓库中

```sh
utane@ubuntu:~/learngit$ vim test.txt
utane@ubuntu:~/learngit$ git add test.txt 
utane@ubuntu:~/learngit$ git commit -m "add test"
[master 47757ee] add test
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
```

- 将工作区的文件删除，然后查看仓库状态，显示有修改没有反应到暂存区，即test.txt的删除动作：

```sh
utane@ubuntu:~/learngit$ rm test.txt 
utane@ubuntu:~/learngit$ git status
ブランチ master
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	deleted:    test.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

针对上面的删除，
1. 一是确实要从版本库中删除文件，那就继续用`git rm test.txt`将删除反应到暂存区，然后commit，这样就真的删除了。
2. 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本，`git checkout -- test.txt`，git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

# 3. 远程仓库

- 使用`ssh-keygen -t rsa -C "lijun.kawasaki@gmail.com"` 创建SSH Key

```
utane@ubuntu:~/learngit$ ssh-keygen -t rsa -C "lijun.kawasaki@gmail.com"
Generating public/private rsa key pair.
Enter file in which to save the key (/home/utane/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/utane/.ssh/id_rsa.
Your public key has been saved in /home/utane/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:ECWmY0c0SRiJNzNaVc2JKHe0EtkNb3kZB8uyGzJnahM lijun.kawasaki@gmail.com
The key's randomart image is:
+---[RSA 2048]----+
|   ..B@O=* .o..  |
|  . X+==+o=o =   |
|   ++*+.. = =    |
|  .. o o . +     |
|        E =      |
|         B o     |
|        + .      |
|       . .       |
|                 |
+----[SHA256]-----+
```

- 在用户主目录下回生成`.ssh`目录，`id_ras`是私钥，`id_rsa.pub`是公钥

```sh
utane@ubuntu:~/learngit$ cd ..
utane@ubuntu:~$ cd .ssh
utane@ubuntu:~/.ssh$ ls
id_rsa  id_rsa.pub
utane@ubuntu:~/.ssh$ cat id_rsa.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC46vQk3pMTLkqiqOJr4TCdoOas3VQWBPANSqHABc4Clu/Pzs3vlYDBOq4SzREXMuZw/Uum0y8D6VyxHDrSGkPQXFabYjdWgG/dpfLnaI2RXFlGhcVOteXTZGa5nb6rrHv+61lFqdPK7q2G35YxCVqo9/UAdGQosOHg2rqpWkpV1DedqGB/taxeENHm69+4uIXSANkZqR7CXGyrUayzZvOuOOqNyhnujpW2wtX2/LFY0jd2YuPQYMrLr8r1Zkt23xsLZ8MeYdPelkJmRF73s9DiQg6fNRu+39nbXY5fAyjo1+kArfTqoxthx3a65nEu0ysexyUBV4swKLATYon/lWcp lijun.kawasaki@gmail.com
```

- 将上面的SSH 公钥，添加到GitHub中

![image](https://user-images.githubusercontent.com/18595935/52933011-30009900-3395-11e9-8308-d1ad96e31b75.png)


## 3.1 添加远程库

- 登录Github，右上角“Create a new repo”按钮，添加一个新的仓库`learngit`

![image](https://user-images.githubusercontent.com/18595935/52933351-64288980-3396-11e9-9fef-3427e2829f30.png)

**…or create a new repository on the command line**

```sh
echo "# learngit" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/utanesuke0612/learngit.git
git push -u origin master
```

**…or push an existing repository from the command line**

```sh
git remote add origin https://github.com/utanesuke0612/learngit.git
git push -u origin master
```

- 根据上面的提示，将本地的仓库与之关联：

> 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。

```sh
utane@ubuntu:~/learngit$ git remote add origin https://github.com/utanesuke0612/learngit.git
```

- 就可以把本地库的所有内容推送到远程库上：

```sh
utane@ubuntu:~/learngit$ git push -u origin master
Username for 'https://github.com': utanesuke0612
Password for 'https://utanesuke0612@github.com': 
Enumerating objects: 20, done.
Counting objects: 100% (20/20), done.
Delta compression using up to 2 threads
Compressing objects: 100% (15/15), done.
Writing objects: 100% (20/20), 1.53 KiB | 785.00 KiB/s, done.
Total 20 (delta 6), reused 0 (delta 0)
remote: Resolving deltas: 100% (6/6), done.
To https://github.com/utanesuke0612/learngit.git
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'.
```

把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。

由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。

从现在起，只要本地作了提交，就可以通过命令：

```sh
$ git push origin master
```

把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！

## 3.2 从远程库克隆

还有一种case，如果是现有远程库，那如何将远程库克隆到本地呢，

假设我们创建了一个新的仓库`udacity`，下面用命令`git clone https://github.com/utanesuke0612/udacitystudy.git`克隆一个到本地

```sh
utane@ubuntu:~$ git clone https://github.com/utanesuke0612/udacitystudy.git
Cloning into 'udacitystudy'...
remote: Enumerating objects: 3, done.
remote: Counting objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
utane@ubuntu:~$ ls
devlj             udacitystudy  デスクトップ  ピクチャ
examples.desktop  ダウンロード  ドキュメント  ミュージック
learngit          テンプレート  ビデオ        公開
```

# 4. 分支管理

## 4.1 创建与合并分支

版本回退中，我们知道每次提交，Git都把他们串成一条时间线，这条时间线就是一个分支。截止目前，这个分支就是主分支，即master分支，现在HEAD严格来说是指向master的，master才是指向提交的。

![image](https://user-images.githubusercontent.com/18595935/52936392-4f9cbf00-339f-11e9-954b-4da658cc13ef.png)

每次提交，master分支都会向前移动一步，如下图：

![image](https://user-images.githubusercontent.com/18595935/52936559-d2be1500-339f-11e9-8b0a-ff1382acb936.png)

当我们创建新的分支，比如dev时，git新建一个指针dev，指向master相同的提交，再把head指向dev，就表示当前分支在dev上。

### 1. 分支操作过程

如下图，分支创建/切换 -> 分支上修改提交 -> 分支合并 -> 分支删除

![image](https://user-images.githubusercontent.com/18595935/52936861-e1f19280-33a0-11e9-8c37-42de96a33bc4.png)

### 2. 示例代码

- 首先创建dev分支，然后切换到dev分支 `git checkout -b dev`
> 后面使用了参数`-b`表示创建并切换，相当于 `git branch dev`和`git checkout dev` 。

```c
utane@ubuntu:~/learngit$ git checkout -b dev
Switched to a new branch 'dev'
```

- 用`git branch`命令查看当前分支，看到当前是dev分支：

```sh
utane@ubuntu:~/learngit$ git branch
* dev
  master
```

- 在当前分支上新建文件，并添加后提交：

```sh
utane@ubuntu:~/learngit$ vi dev.txt
utane@ubuntu:~/learngit$ git add dev.txt
utane@ubuntu:~/learngit$ git commit -m "test branch dev"
[dev 40ae6e5] test branch dev
 1 file changed, 3 insertions(+)
 create mode 100644 dev.txt
```

- 可以看到下面多了一个文件

```sh
utane@ubuntu:~/learngit$ ls
LICENSE  dev.txt  readme.txt
```

- `git checkout master`切换到master上，master中没有改文件

```sh
utane@ubuntu:~/learngit$ git checkout master
Switched to branch 'master'
Your branch is up to date with 'origin/master'.
utane@ubuntu:~/learngit$ ls
LICENSE  readme.txt
```

- `git merge dev` 将dev分支合并到当前的master上

```sh
utane@ubuntu:~/learngit$ git merge dev
Updating d720cf6..40ae6e5
Fast-forward
 dev.txt | 3 +++
 1 file changed, 3 insertions(+)
 create mode 100644 dev.txt
```

- `git branch -d dev` 将dev分支删除

```sh
utane@ubuntu:~/learngit$ git branch -d dev
Deleted branch dev (was 40ae6e5).
utane@ubuntu:~/learngit$ git branch
* master
```

## 4.2 解决冲突

合并分支的时候，出现冲突是常见的：

- 创建一个新的分支：

```sh
utane@ubuntu:~/learngit$ git checkout -b feature1
Switched to a new branch 'feature1'
utane@ubuntu:~/learngit$ git branch
* feature1
  master

```

- 在该分支上修改文件，并提交，

```sh
utane@ubuntu:~/learngit$ vim readme.txt 
utane@ubuntu:~/learngit$ git add readme.txt 
utane@ubuntu:~/learngit$ git commit -m "feature1 5th"
[feature1 44a9a3b] feature1 5th
 1 file changed, 2 insertions(+)
```

- 切换到master分支，切换的时候会出现提示，说当前的分支比远程(origin)的分支多一次提交：

```sh
utane@ubuntu:~/learngit$ git checkout master
Switched to branch 'master'
このブランチは 'origin/master' よりも1コミット進んでいます。
  (use "git push" to publish your local commits)
```

- 在master上也对相同的文件进行修改，并commit：

```sh
utane@ubuntu:~/learngit$ vi readme.txt 
utane@ubuntu:~/learngit$ git add readme.txt 
utane@ubuntu:~/learngit$ git commit -m "create new master"
[master d19476e] create new master
 1 file changed, 1 insertion(+)
```

- 现在分支master和feature都有相同文件的修改，这种合并就可能造成冲突：

```sh
utane@ubuntu:~/learngit$ git merge feature1 
Auto-merging readme.txt
CONFLICT (content): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.
```

- 果然上面冲突了，通过git status查看readme.txt存在冲突，必须手动解决后再提交。

```sh
utane@ubuntu:~/learngit$ git status
ブランチ master
このブランチは 'origin/master' よりも2コミット進んでいます。
  (use "git push" to publish your local commits)

You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)

	both modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

- 可以直接查看 readme.txt文件，手动修改，Git用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容，

```sh
utane@ubuntu:~/learngit$ cat readme.txt 
Git is a version control system.
Git is free software.

add more @1st
add more @2nd
add more @3rd
add more @4th
<<<<<<< HEAD
creating a new branch @master 5th
=======

Createing new branch is quick @feature 5th
>>>>>>> feature1
```

- 修改后，再提交：



```sh
utane@ubuntu:~/learngit$ vi readme.txt 
utane@ubuntu:~/learngit$ cat readme.txt 
Git is a version control system.
Git is free software.

add more @1st
add more @2nd
add more @3rd
add more @4th
creating a new branch @master 5th
Createing new branch is quick @feature 5th
```

```sh
utane@ubuntu:~/learngit$ git add readme.txt 
utane@ubuntu:~/learngit$ git branch
  feature1
* master
utane@ubuntu:~/learngit$ git commit -m "conflict fixed"
[master e0efded] conflict fixed
utane@ubuntu:~/learngit$ git status
ブランチ master
このブランチは 'origin/master' よりも4コミット進んでいます。
  (use "git push" to publish your local commits)

nothing to commit, working tree clean
```

## 4.3 分支管理策略

通常合并分支的时候，Git会用 Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。

通过`--no-ff`方式进行git merge的话，git会在merge上再生成一个新的commit，这样，从分支历史上就可以看出分支信息：

- 新建并切换到分支 dev上

```sh
utane@ubuntu:~/learngit$ git checkout -b dev
Switched to a new branch 'dev'
utane@ubuntu:~/learngit$ ls
LICENSE  dev.txt  readme.txt
```

- 修改文件并提交：

```sh
utane@ubuntu:~/learngit$ vim readme.txt 
utane@ubuntu:~/learngit$ git add readme.txt 
utane@ubuntu:~/learngit$ git commit -m "add merge"
[dev d64b13e] add merge
 1 file changed, 2 insertions(+)
```

- 切换到master上，并合并dev：`git merge --no-ff -m "merge with no-ff" dev`
> 因为本次合并要创建一个新的commit，所以加上`-m`参数，把commit描述写进去。

```sh
utane@ubuntu:~/learngit$ git checkout master
Switched to branch 'master'
このブランチは 'origin/master' よりも4コミット進んでいます。
  (use "git push" to publish your local commits)
utane@ubuntu:~/learngit$ git merge --no-ff -m "merge with no-ff" dev
Merge made by the 'recursive' strategy.
 readme.txt | 2 ++
 1 file changed, 2 insertions(+)
```

- 通过 `git log --graph --pretty=oneline --abbrev-commit` 查看分支历史

```sh
utane@ubuntu:~/learngit$ git log --graph --pretty=oneline --abbrev-commit
*   ca3e8c5 (HEAD -> master) merge with no-ff
|\  
| * d64b13e (dev) add merge
|/  
*   e0efded conflict fixed
|\  
| * 44a9a3b feature1 5th
* | d19476e create new master
|/  
* 40ae6e5 test branch dev
* d720cf6 (origin/master) delete test
* 47757ee add test
* 18de63f git tracks changes
* 87486c1 uderstand stage:add license
* eb699b8 add more 2nd
* 0e6ec7c add more 1st
* 4568339 wrote a readme file
```

## 4.4 Bug分支

软件开发中，bug是常有的，如果我现在的dev分支中开发新功能，但是突然来了一个bug，而dev中的新功能还没有提交。
这时针对这个bug，可以通过一个新的临时分支来修复，修复后，合并分支，并将这个bug分支删除即可。

- 比如下面，我在dev分支下，暂存区的文件还没有提交：

```sh
utane@ubuntu:~/learngit$ git checkout dev
Switched to branch 'dev'
utane@ubuntu:~/learngit$ git branch
* dev
  master

utane@ubuntu:~/learngit$ git status
ブランチ dev
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

- Git还提供了一个`stash`功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作.

```sh
utane@ubuntu:~/learngit$ git stash
Saved working directory and index state WIP on dev: d64b13e add merge
```

- 然后查看工作区，就是干净的了，可以放心创建新的分支修复bug。

```sh
utane@ubuntu:~/learngit$ git status
ブランチ dev
nothing to commit, working tree clean
```

- 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：

```sh
utane@ubuntu:~/learngit$ git checkout master
Switched to branch 'master'
このブランチは 'origin/master' よりも6コミット進んでいます。
  (use "git push" to publish your local commits)
utane@ubuntu:~/learngit$ git checkout -b issue-101
Switched to a new branch 'issue-101'
```

- bug修复，并提交：

```sh
utane@ubuntu:~/learngit$ vim readme.txt 
utane@ubuntu:~/learngit$ 
utane@ubuntu:~/learngit$ git add readme.txt 
utane@ubuntu:~/learngit$ git commit -m "fix bug 101"
[issue-101 5508d90] fix bug 101
 1 file changed, 1 insertion(+)
```

- 切换到master分支，并将bug分支merge进来：

```sh
utane@ubuntu:~/learngit$ git checkout master
Switched to branch 'master'
このブランチは 'origin/master' よりも6コミット進んでいます。
  (use "git push" to publish your local commits)
utane@ubuntu:~/learngit$ git merge --no-ff -m "merged bug fix 101" issue-101
Merge made by the 'recursive' strategy.
 readme.txt | 1 +
 1 file changed, 1 insertion(+)
```

- 最后删除bug分支

```sh
git branch -d issue-101 
```

- 再重新切回dev分支开发新功能

```sh
utane@ubuntu:~/learngit$ git checkout dev
Switched to branch 'dev'
utane@ubuntu:~/learngit$ git status
ブランチ dev
nothing to commit, working tree clean
```

- 上面的命令查看到工作区是干净的，因为要工作保存到了某个地方，可以如下命令查看

```sh
utane@ubuntu:~/learngit$ git stash list
stash@{0}: WIP on dev: d64b13e add merge
```

- 接着就是从某个地方将保存的内容恢复了，有两种方式：
	+ 1. 用`git stash apply`恢复，但是恢复后，stash内容并不删除，你需要用`git stash drop`来删除；
	+ 2. 用`git stash pop`，恢复的同时把stash内容也删了

```sh
utane@ubuntu:~/learngit$ git stash pop
ブランチ dev
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
Dropped refs/stash@{0} (6646bc908bea25d718fd1f3bd969d92c776b7fb5)
```

## 4.5 Feature分支

每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。

- 添加一个新分支`feature-vulcan`

```sh
utane@ubuntu:~/learngit$ git checkout -b feature-vulcan
M	readme.txt
Switched to a new branch 'feature-vulcan'
```

- 添加新的功能文件，并commit到对应的新分支

```sh
utane@ubuntu:~/learngit$ vim vulcan.py
utane@ubuntu:~/learngit$ 
utane@ubuntu:~/learngit$ git add vulcan.py 
utane@ubuntu:~/learngit$ git commit -m "new feature vulcan"
[feature-vulcan 44240ba] new feature vulcan
 1 file changed, 1 insertion(+)
 create mode 100644 vulcan.py
```

- 然后切换到当前的dev开发分支

```sh
utane@ubuntu:~/learngit$ git checkout dev
M	readme.txt
Switched to branch 'dev'
```

- 这时如果功能取消，不需要合并了，那需要将分支删除，如果是`-d`的话，提示该分支没有被合并，强制删除的话，需要用`-D`

```sh
utane@ubuntu:~/learngit$ git branch -d feature-vulcan 
error: The branch 'feature-vulcan' is not fully merged.
If you are sure you want to delete it, run 'git branch -D feature-vulcan'.
utane@ubuntu:~/learngit$ git branch -D feature-vulcan 
Deleted branch feature-vulcan (was 44240ba).
utane@ubuntu:~/learngit$ 
```

## 4.6 多人协作

## 4.7 Rebase

# 5. 标签管理

## 5.1 创建标签

## 5.2 操作标签

# 6. 自定义Git

## 6.1 忽略特殊文件

## 6.2 配置别名

## 6.3 搭建Git服务器