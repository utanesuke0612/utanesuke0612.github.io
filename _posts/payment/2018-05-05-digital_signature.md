---
layout: post
title: 什么是数字签名？
date: 2018-05-04 01:00:00
categories: Payment
tags: Payment
---
* content
{:toc}

> 参考 [数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html) 作成，为加深印象以及方便今后查阅，总结于此。


# 1. 什么是密钥

在进行数字签名的讲解之前，先对什么是密钥进行说明，加密的方式一般有两类，第一种是单钥加密(private key crytography)，还有一种是双钥加密(public key crytography),前者加密解密使用同一套密码(也叫对称加密)，而后者加密解密使用不同的密码。

## 1.1 单钥加密

在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。
因此加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。

- 工作过程

下面举个例子来简要说明一下对称加密的工作过程:

甲和乙是一对生意搭档，他们住在不同的城市。由于生意上的需要，他们经常会相互之间邮寄重要的货物。为了保证货物的安全，他们商定制作一个保险盒，将物品放入其中。他们打造了两把相同的钥匙分别保管，以便在收到包裹时用这个钥匙打开保险盒，以及在邮寄货物前用这把钥匙锁上保险盒。

上面是一个将重要资源安全传递到目的地的传统方式，只要甲乙小心保管好钥匙，那么就算有人得到保险盒，也无法打开。这个思想被用到了现代计算机通信的信息加密中。在对称加密中，数据发送方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。接收方收到密文后，若想解读原文，则需要使用加密密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密。

![image](https://user-images.githubusercontent.com/18595935/39663204-e86885a4-50a9-11e8-9c31-32c33589282b.png)

在对称加密算法中常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES等。


## 1.2 双钥加密

在双钥加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。在双钥体系中，公钥用来加密信息，私钥用来数字签名。

双钥加密的原理如下：
1. 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。
2. 所有的（公钥, 私钥）对都是不同的。
3. 用公钥可以解开私钥加密的信息，反之亦成立。
4. 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。

通用的双钥加密算法为RSA（ Rivest-Shamir-Adleman）

因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。目前，世界上最主要的数字服务认证商是位于美国加州的Verisign公司，它的主要业务就是分发RSA数字证书。

# 2. 示例-数字签名

- 鲍勃有两把钥匙，一把是公钥，另一把是私钥。鲍勃把公钥送给他的朋友们----帕蒂、道格、苏珊----每人一把。

![image](https://user-images.githubusercontent.com/18595935/39663391-abf73db4-50ad-11e8-8489-9653d2284a93.png)

- 苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。

![image](https://user-images.githubusercontent.com/18595935/39663414-f5831ab6-50ad-11e8-9a10-802c23543b71.png)

- 鲍勃给苏珊回信，决定采用"数字签名"。他写完后先用Hash函数，生成信件的摘要（digest）。然后，鲍勃使用私钥，对这个摘要加密，生成"数字签名"（signature）。鲍勃将这个签名，附在信件下面，一起发给苏珊。

![image](https://user-images.githubusercontent.com/18595935/39663428-27c9fa44-50ae-11e8-85f0-6aa7f58aa080.png)

- 苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。

![image](https://user-images.githubusercontent.com/18595935/39663439-5e09143c-50ae-11e8-8aef-a91e64a1742f.png)

- 复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成"数字签名"，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。

![image](https://user-images.githubusercontent.com/18595935/39663463-d4559476-50ae-11e8-8fd9-cd6e1ffe58ef.png)

- 后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找"证书中心"（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成"数字证书"（Digital Certificate）。

![image](https://user-images.githubusercontent.com/18595935/39663473-fd71b592-50ae-11e8-8a84-ac5a0b5593f4.png)

- 鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。

![image](https://user-images.githubusercontent.com/18595935/39663480-28c95736-50af-11e8-8a67-0e0bb9b0e914.png)

- 苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明"数字签名"是否真的是鲍勃签的。

![image](https://user-images.githubusercontent.com/18595935/39663487-3433994c-50af-11e8-807f-6bbf222bea27.png)

# 3. "数字证书"的实例：https协议

https协议主要用于网页加密。

- 首先，客户端向服务器发出加密请求。服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。

![image](https://user-images.githubusercontent.com/18595935/39663557-5a48e69a-50b0-11e8-91c3-c214314b13d0.png)

- 客户端（浏览器）的"证书管理器"，有"受信任的根证书颁发机构"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。

![image](https://user-images.githubusercontent.com/18595935/39663573-8b5e6142-50b0-11e8-82d4-c8c0c14a45aa.png)

- 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。

![image](https://user-images.githubusercontent.com/18595935/39663579-9d50af04-50b0-11e8-8a69-6751a56a1ded.png)

- 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。

![image](https://user-images.githubusercontent.com/18595935/39663580-a5fe5c82-50b0-11e8-8175-5ec65a3834e8.png)

- 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。

![image](https://user-images.githubusercontent.com/18595935/39663585-b51c88c4-50b0-11e8-9b81-9e1bc9bb7c8e.png)

# 4. 后记

在实际的业务中，客户调用自己的API，并传递过来信息，这是客户会使用加密，自己这一端需要解密。同样的，自己这一端需要将信息发送客户，也会加密信息，客户那一端也需要解密。
双方加密时，都使用自身的私钥，解密对方信息时，使用对方的公钥，所以双方需要交换公钥。


